#!/usr/bin/env python
# -*- coding: us-ascii -*-
# generated by wxGlade 0.5 on Tue Jun 26 11:07:06 2007

# Wizard for downloading and installing missing dependencies
# MVCTreeOverView for illustrating taxonomy summaries

# py2applet --make-setup gui.py
# python setup.py py2app -A --use-pythonpath
# python setup.py py2app --use-pythonpath

# Standard libs:
try:
   import cPickle as pickle
except:
   import pickle
import sys, re, os, copy, time, glob, traceback
from optparse import OptionParser
from math import floor

# BioPython modules:
from Bio.Nexus import Nexus, Trees, Nodes

from SAP import Fasta, NeighbourJoin, MachinePool, Options

# Custom modules:
from SAP.XML2Obj import XML2Obj
from SAP.Homology import HomolCompiler, HomologySet, Homologue
from SAP.TreeStatistics import TreeStatistics
from SAP.PairWiseDiffs import PairWiseDiffs
from SAP.ResultHTML import ResultHTML
from SAP.Initialize import Initialize

# We need to import these here so py2app can map them as dependencies:
from SAP.Assignment import Barcoder, ConstrainedNJ
from SAP.Alignment import Clustalw2
        
from SAP.UtilityFunctions import *
from SAP.FindPlugins import *
from SAP.InstallDependencies import *

import sys, os, time
try:
   import wx
   import wx.lib.rcsizer  as rcs
   import wx.lib.scrolledpanel as scrolled
   import wx.lib.filebrowsebutton as filebrowse
   from wx.lib.mixins.listctrl import CheckListCtrlMixin
   from wx.lib.wordwrap import wordwrap
   import wx.lib.delayedresult as delayedresult
   import wx.lib.hyperlink as hyperlink
   #----------------------------------------------------------------------
   # We first have to set an application-wide help provider.  Normally you
   # would do this in your app's OnInit or in other startup code...
   provider = wx.SimpleHelpProvider()
   wx.HelpProvider_Set(provider)
except ImportError:
   print "You need to install wxPython to be able to run sap_gui from the command line"
   sys.exit()

wildcard = "Fasta files (*.fasta)|*.fasta|"     \
           "All files (*.*)|*.*"

# optionParser = None
# sys.argv = [None]
optionParser = Options.Options()
optionParser.options.project = ''

import Queue
outputQueue = Queue.Queue()


class MyDropTarget(wx.FileDropTarget):
    def __init__(self, window, textctrl):
        wx.FileDropTarget.__init__(self)
        self.window = window
        self.textctrl = textctrl

    def typeErrorDialog(self, text):
        dlg = wx.MessageDialog(self.window, text, 'Type error.', wx.OK | wx.ICON_ERROR)
        dlg.ShowModal()
        dlg.Destroy()

class MyFileDropTarget(MyDropTarget):

   def OnDropFiles(self, x, y, filenames):
       for f in filenames:
           if not os.path.isfile(f):
               self.typeErrorDialog('%s is not a file.' % f)
               return
           if f.find(" ") > 0:
               self.typeErrorDialog('File name: %s constains space characters.' % f)
               return
       self.textctrl.SetInsertionPointEnd()
       self.textctrl.WriteText("\n".join(filenames) + "\n")


class MyDirDropTarget(MyDropTarget):

   def OnDropFiles(self, x, y, filenames):
       for f in filenames:
          if not os.path.isdir(f):
             self.typeErrorDialog('%s is not a directory.' % f)
             return
       self.textctrl.SetInsertionPointEnd()
       self.textctrl.WriteText(" ".join(filenames))

class OutputEnqueue:
    def __init__(self):
        pass
    def write(self, s):
        outputQueue.put(s)
    def flush(self):
        pass

class LogFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        self.log = LogWindow(self)

        self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)
        self.Bind(wx.EVT_WINDOW_DESTROY, self.OnWindowDestroy)

    def OnCloseWindow(self, event):
        self.Hide()

    def OnWindowDestroy(self, event):
        self.Hide()

class LogWindow(wx.TextCtrl):
    def __init__ (self, frame):

        self.parent = frame

        wx.TextCtrl.__init__(self,self.parent,size=self.parent.GetClientSize(),
                             style=wx.TE_MULTILINE|wx.TE_READONLY|wx.HSCROLL)

        style = wx.TextAttr()
        style.SetFont(wx.Font(11, wx.SWISS, wx.NORMAL, wx.NORMAL, False, 'Verdana'))
        self.SetDefaultStyle(style)

        # Bind all EVT_TIMER events to self.OnTest1Timer
        self.Bind(wx.EVT_TIMER, self.onTimer)
        self.startTimer()

    def startTimer(self):
        self.timer1 = wx.Timer(self)
        self.timer1.Start(1000)

    def stopTimer(self):
        self.timer1.Stop()
        del self.timer1

    def onTimer(self, evt):
        output = []
        for s in self.getAllFromQueue(outputQueue):
            self.write(s)

    def getAllFromQueue(self, Q):
        """Generator to yield one after the others all item currently in
        the queue Q, without any waiting"""
        try:
            while True:
                yield Q.get_nowait()
        except Queue.Empty:
            raise StopIteration

    def flush(self):
        pass

class OptionsValidator(wx.PyValidator):
     """ This validator is used to ensure that the user has entered something
         into the text object editor dialog's text field.
     """
     def __init__(self, optionName):
         """ Standard constructor.
         """
         wx.PyValidator.__init__(self)

         self.optionName = optionName

     def Clone(self):
         """ Standard cloner.

             Note that every validator must implement the Clone() method.
         """
         return OptionsValidator(self.optionName)

     def Validate(self, win):
         """ Validate the contents of the given text control.
         """
         textCtrl = self.GetWindow()
         text = textCtrl.GetValue()

         inputError = False

         if text != '':
            # Find type of option and convert to that type
            origValue = getattr(optionParser.options, self.optionName)
            try:
               if type(origValue) == type(True):
                   if text == 'True':
                       newValue = True
                   elif text == 'False':
                       newValue = False
                   else:
                       inputError = True
               elif type(origValue) == type([]):
                  newValue = re.split(r'\s*,\s*', text)
                  if type(origValue[0]) == type(1):
                     newValue = [int(x) for x in newValue]
                  elif type(origValue[0]) == type(1.1):
                     newValue = [float(x) for x in newValue]
               elif type(origValue) == type(1.1):
                   newValue = float(text)
               elif type(origValue) == type(1):
                   newValue = int(text)
               else:
                   newValue = text
            except ValueError:
               inputError = True

         elif not getattr(optionParser.options, self.optionName):            
            newValue = None
         else:            
            inputError = True

         # Make some sanity checks:
         if inputError:
             if text == '':
                msg = "You cannot leave input fields blank"
             else:
                msg = "Invalid input value: %s" % text
             wx.MessageBox(msg , "Input Error")
             textCtrl.SetBackgroundColour("pink")
             textCtrl.SetFocus()
             textCtrl.Refresh()
             return False
         else:
             setattr(optionParser.options, self.optionName, newValue)

             textCtrl.SetBackgroundColour(
                 wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW))
             textCtrl.Refresh()
             return True

     def TransferToWindow(self):
         """ Transfer data from validator to window.

             The default implementation returns False, indicating that an error
             occurred.  We simply return True, as we don't do any data transfer.
         """
         return True # Prevent wxDialog from complaining.

     def TransferFromWindow(self):
         """ Transfer data from window to validator.

             The default implementation returns False, indicating that an error
             occurred.  We simply return True, as we don't do any data transfer.
         """
         return True # Prevent wxDialog from complaining.

class BoundTextCtrl(wx.TextCtrl):
    def __init__ (self, parent, optionName):
        wx.TextCtrl.__init__(self, parent, -1, self.formatDefaultSring(optionParser, optionName), size=(100, -1), validator=OptionsValidator(optionName))

        self.Bind(wx.EVT_TEXT, self.EvtText)
        self.Bind(wx.EVT_CHAR, self.EvtChar)
        self.Bind(wx.EVT_SET_FOCUS, self.OnSetFocus)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)
        self.Bind(wx.EVT_WINDOW_DESTROY, self.OnWindowDestroy)

    def formatDefaultSring(self, optionParser, optionName):
       opt = getattr(optionParser.options, optionName)

       if opt is None:
          return ''
       elif type(opt) == type([]):
          if len(opt) == 1:
             return str(opt[0])
          else:
             return ", ".join(opt)
       else:
          return str(opt)

    def EvtText(self, evt):
        varString = evt.GetString()

    def EvtTextEnter(self, evt):
        evt.Skip()

    def EvtChar(self, evt):
        evt.Skip()

    def OnSetFocus(self, evt):
        evt.Skip()

    def OnKillFocus(self, evt):
        evt.Skip()

    def OnWindowDestroy(self, evt):
        evt.Skip()

class BoolChoice(wx.Choice):
    def __init__ (self, parent, optionName, choiceList=[]):
       self.optionName = optionName
       opt = getattr(optionParser.options, self.optionName)
       if opt is True:
          choiceList = ['Yes', 'No']
       else:
          choiceList = ['No', 'Yes']
       wx.Choice.__init__(self, parent, -1, pos=(100, 50), size=(100,-1), choices = choiceList)
       self.Bind(wx.EVT_CHOICE, self.EvtChoice, self)

    def EvtChoice(self, event):
       choice = event.GetString()
       if choice == 'Yes':
          choice = True
       if choice == 'No':
          choice = False
       setattr(optionParser.options, self.optionName, choice)

class StringChoice(wx.Choice):
    def __init__ (self, parent, optionName, choiceList=[]):
       self.optionName = optionName
       self.choiceList = choiceList
       opt = getattr(optionParser.options, self.optionName)       
       wx.Choice.__init__(self, parent, -1, pos=(100, 50), size=(100,-1), choices = self.choiceList)

       currentVal = getattr(optionParser.options, optionName)
       if choiceList[0] != currentVal:
          # remove the current val from where it is in the list:
          for i, s in enumerate(choiceList):
             if s == currentVal:
                choiceList.pop(i)
                break             
          # Put the list back together in the right order:
          self.SetString(0, currentVal)
          for i in range(1-len(choiceList)-1):
             self.SetString(choiceList[i], currentVal)
          self.Append(choiceList[-1])


       self.Bind(wx.EVT_CHOICE, self.EvtChoice, self)

    def EvtChoice(self, event):
       choice = event.GetString()
       setattr(optionParser.options, self.optionName, choice)

class DatabaseChoice(StringChoice):

    def fileBrowse(self):
        dlg = wx.FileDialog(
            self, message="Choose a local file to use as database. See manual for formating details.",
            defaultDir=os.getcwd(), 
            defaultFile="",
            wildcard=wildcard,
            #style=wx.OPEN | wx.MULTIPLE | wx.CHANGE_DIR
            style=wx.OPEN
            )

        if dlg.ShowModal() == wx.ID_OK:
            # This returns a Python list of files that were selected.
            paths = dlg.GetPaths()
            self.inputFiles = paths
            self.choice = paths[0]
        else:
           self.choice = None

        dlg.Destroy()

    def EvtChoice(self, event):
        self.choice = event.GetString()
        if self.choice == 'Add local file to list...':
            self.fileBrowse()
            if self.choice is not None:
               self.SetString(len(self.choiceList)-1, self.choice)
               self.Append('Add local file to list...')
               setattr(optionParser.options, self.optionName, self.choice)
            else:

#                # Turn the list back to what is was before:
#                oldChoiceList = self.choiceList
#                i = 0
#                for s in oldChoiceList:
#                   if s != getattr(optionParser.options, self.optionName):
#                      print i, s
#                      self.SetString(i, s)
#                      i += 1
#                self.SetString(i, getattr(optionParser.options, self.optionName))      

               dlg = wx.MessageDialog(self, 'You canceled choice of a local database file so you need to re-select one of the built in databases.', 'Select a database', wx.OK | wx.ICON_INFORMATION)
               dlg.ShowModal()
               dlg.Destroy()

        else:
           setattr(optionParser.options, self.optionName, self.choice)


class OptionsDialog(wx.Dialog):
    def __init__(self, parent):
        wx.Dialog.__init__(self, parent, -1, "Options")

        global optionParser

        self.SetAutoLayout(True)

        # Sizer for the entire tab:
        #sizer = wx.BoxSizer(wx.VERTICAL)
        sizer = wx.BoxSizer(wx.HORIZONTAL)
        col1sizer = wx.BoxSizer(wx.VERTICAL)
        col2sizer = wx.BoxSizer(wx.VERTICAL)

        sizer.Add(col1sizer, 0, 0, 0)
        sizer.Add(col2sizer, 0, 0, 0)
        
        box1 = wx.StaticBox(self, -1, "Compilation of set of homologues")
        box1sizer = wx.StaticBoxSizer(box1, wx.VERTICAL)
        
        # grid sizer to go inside box sizer:
        box1GridSizer = wx.FlexGridSizer(cols=4, hgap=20, vgap=5)

        box1sizer.Add(box1GridSizer, 0, wx.TOP|wx.LEFT, 10)
        col1sizer.Add(box1sizer, 0, wx.ALL, 10)

        objList = []

        usedList = ['--database',             '--harddiversity',
                    '--inputformat',          '--phyla',             
                    '--quickcompile',         '--classes',           
                    '--limitquery',           '--orders',            
                    '--nolowcomplexfilter',   '--families',          
                    '--maxblasthits',         '--genera',            
                    '--besthits',             '--individuals',       
                    '--alignmentlimit',       '--nofillin',           
                    '--relbitscore',          '--fillinall',         
                    '--significance',         '--fillintomatch',     
                    '--nrsignificant',        '--forceexcludegilist',
                    '--minsignificance',      '--forceincludegilist',  
                    '--minidentity',          '--forceidentity',                                             
                    '--subspecieslevel',      '--forceincludefile'                                               
                    ]

        for optionName in usedList:
            option = optionParser.parser.get_option(optionName)
            l = wx.StaticText(self, -1, "%s:" % option.dest, size=(130, -1))
            if optionName == '--database':
               t = DatabaseChoice(self, option.dest, ['GenBank', 'Add local file to list...'])
            elif type(getattr(optionParser.options, option.dest)) == type(True):
               t = BoolChoice(self, option.dest)
            else:
               t = BoundTextCtrl(self, option.dest)
            l.SetHelpText(option.help)            
            objList.extend([l,t])


        # Add the fields to the grid sizer:
        box1GridSizer.AddMany(objList)

        box2 = wx.StaticBox(self, -1, "Alignment")
        box2sizer = wx.StaticBoxSizer(box2, wx.VERTICAL)
        
        # grid sizer to go inside box sizer:
        box2GridSizer = wx.FlexGridSizer(cols=2, hgap=20, vgap=5)

        box2sizer.Add(box2GridSizer, 0, wx.TOP|wx.LEFT, 10)
        col2sizer.Add(box2sizer, 0, wx.ALL, 10)

        objList = []

        usedList = ['--alignment', '--warnongaps', '--alignmentoption']

        for optionName in usedList:
            option = optionParser.parser.get_option(optionName)
            l = wx.StaticText(self, -1, "%s:" % option.dest, size=(130, -1))
            if optionName == '--alignment':
               t = StringChoice(self, option.dest, ['Clustalw2'])
            elif type(getattr(optionParser.options, option.dest)) == type(True):
               t = BoolChoice(self, option.dest)
            else:
               t = BoundTextCtrl(self, option.dest)
            l.SetHelpText(option.help)            
            objList.extend([l,t])

        # Add the fields to the grid sizer:
        box2GridSizer.AddMany(objList)

        box3 = wx.StaticBox(self, -1, "Tree sampling and assignmnet statistics")
        box3sizer = wx.StaticBoxSizer(box3, wx.VERTICAL)
        
        # grid sizer to go inside box sizer:
        box3GridSizer = wx.FlexGridSizer(cols=2, hgap=20, vgap=5)

        box3sizer.Add(box3GridSizer, 0, wx.TOP|wx.LEFT, 10)
        col2sizer.Add(box3sizer, 0, wx.ALL, 10)

        objList = []

        usedList = ['--prunelevel', '--assignment']

        for optionName in usedList:
            option = optionParser.parser.get_option(optionName)
            l = wx.StaticText(self, -1, "%s:" % option.dest, size=(130, -1))
            if optionName == '--assignment':
               t = StringChoice(self, option.dest, ['Barcoder', 'ConstrainedNJ'])
            else:
               t = BoundTextCtrl(self, option.dest)
            l.SetHelpText(option.help)            
            objList.extend([l,t])

        # Add the fields to the grid sizer:
        box3GridSizer.AddMany(objList)

        box4 = wx.StaticBox(self, -1, "Result formatting options")
        box4sizer = wx.StaticBoxSizer(box4, wx.VERTICAL)
        
        # grid sizer to go inside box sizer:
        box4GridSizer = wx.FlexGridSizer(cols=2, hgap=20, vgap=5)

        box4sizer.Add(box4GridSizer, 0, wx.TOP|wx.LEFT, 10)
        col2sizer.Add(box4sizer, 0, wx.ALL, 10)

        objList = []

        usedList = ['--ppcutoff', '--svg', '--cleanlook', '--diffs']

        for optionName in usedList:
            option = optionParser.parser.get_option(optionName)
            l = wx.StaticText(self, -1, "%s:" % option.dest, size=(130, -1))
            if type(getattr(optionParser.options, option.dest)) == type(True):
               t = BoolChoice(self, option.dest)
            else:
               t = BoundTextCtrl(self, option.dest)
            l.SetHelpText(option.help)            
            objList.extend([l,t])

        # Add the fields to the grid sizer:
        box4GridSizer.AddMany(objList)

        border = wx.BoxSizer(wx.VERTICAL)

        cBtn = wx.ContextHelpButton(self)
        cBtn.SetHelpText("FIRST click the question mark and THEN the option name you need help on.")
        cBtnText = wx.StaticText(self, -1, "Help: Click the question mark and then the option name you need help on.")

        helpBox = wx.BoxSizer(wx.HORIZONTAL)
        helpBox.Add(cBtn, 0, wx.ALL, 5)
        helpBox.Add(cBtnText, 0, wx.ALL, 5)
        border.Add(helpBox, 0, wx.ALL, 5)

        border.Add(sizer, 1, wx.GROW|wx.ALL, 10)
        
        # Ok and cancel buttons:
        buttons = wx.StdDialogButtonSizer()
        b = wx.Button(self, wx.ID_OK, "OK")
        b.SetDefault()
        buttons.AddButton(b)
        buttons.AddButton(wx.Button(self, wx.ID_CANCEL, "Cancel"))
        buttons.Realize()

        border.Add(buttons, 0, wx.ALIGN_RIGHT)
        border.Add((10,10))

        self.SetSizer(border)
        border.Fit(self)
        self.Layout()

class MyFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)

#         self.Bind(wx.EVT_WINDOW_DESTROY, self.OnWindowDestroy)

        self.webSite = "http://ib.berkeley.edu/labs/slatkin/munch/StatisticalAssignmentPackage.html"
        # Frame title
        self.SetTitle("Statistical Assignment Package")

        self.logframe = LogFrame(self, -1, "Log", size=(700, 500))

        # Prepare the menu bar
        menuBar = wx.MenuBar()
        # 1st menu from left
        menu1 = wx.Menu()
        menu1.Append(102, "Open existing project\tCtrl+O")

        # Add a custum menu item for quit: - Maybe implement all of the menus this way instead of using the numbers and binding at the end....
        item = menu1.Append(wx.ID_EXIT, text = "&Exit")
        self.Bind(wx.EVT_MENU, self.onQuit, item)

        # Add menu to the menu bar
        menuBar.Append(menu1, "File")
        # Shortcuts
        menu2 = wx.Menu()
        menu2.Append(201, "Results\tCtrl+R", "Open results in browser window")
        ## menu2.Append(202, "Options\tShift+O")
        menu2.Append(203, "Log\tShift+L")
        menuBar.Append(menu2, "&View")
        # Help
        menu3 = wx.Menu()
        menu3.Append(301, "Online Manual\tCtrl+H")
        menu3.AppendSeparator()
        menu3.Append(302, "About")
        menuBar.Append(menu3, "&Help")

        self.SetMenuBar(menuBar)

        self.Bind(wx.EVT_MENU, self.openProject, id=102)        
        self.Bind(wx.EVT_MENU, self.showResults, id=201)
        self.Bind(wx.EVT_MENU, self.menu203, id=203)
        self.Bind(wx.EVT_MENU, self.menu301, id=301)
        self.Bind(wx.EVT_MENU, self.menu302, id=302)

        self.resultPath = None

        self.jobID = 0
        self.abortEvent = delayedresult.AbortEvent()
        
        self.panel = panel = scrolled.ScrolledPanel(self, -1, style = wx.TAB_TRAVERSAL, name="panel1" )

        # Sizer for the entire tab:
        tabSizer = wx.BoxSizer(wx.VERTICAL)

        topText = "Specify sequence file (Fasta format) and project directory for project files:"
        tabSizer.Add(wx.StaticText(panel, -1, topText), 0, wx.ALL, 10)

        # Make a sizer for the top input fields and add it to the top sizer with a bit of margin:
        topGridSizer = wx.FlexGridSizer(cols=3, hgap=14, vgap=14)
        tabSizer.Add(topGridSizer, 1, wx.EXPAND|wx.ALL, 10)

        self.l1 = l1 = wx.StaticText(panel, -1, "Sequence files:")
        self.t1 = t1 = wx.TextCtrl(panel, -1, "", size=(350, 50), style=wx.TE_MULTILINE)
        #self.t1 = t1 = wx.TextCtrl(panel, -1, "", size=(350, -1))
        dt1 = MyFileDropTarget(self, t1)
        self.t1.SetDropTarget(dt1)
        self.b1 = b1 = wx.Button(panel, -1, "Browse")
        self.Bind(wx.EVT_BUTTON, self.onFileBrowseButton, b1)
        wx.CallAfter(t1.SetInsertionPoint, 0)

        self.l2 = l2 = wx.StaticText(panel, -1, "Project folder:")
        self.t2 = t2 = wx.TextCtrl(panel, -1, "", size=(350, -1))
        dt2 = MyDirDropTarget(self, t2)
        self.t2.SetDropTarget(dt2)
        self.b2 = b2 = wx.Button(panel, -1, "Browse")
        self.Bind(wx.EVT_BUTTON, self.onDirBrowseButton, b2)
        wx.CallAfter(t2.SetInsertionPoint, 0)

        self.l3 = l3 = wx.StaticText(panel, -1, "Email:")
        self.t3 = t3 = wx.TextCtrl(panel, -1, "", size=(350, -1))


        self.runB = runB = wx.Button(panel, -1, "Run")        
        runB.SetDefault()
        self.Bind(wx.EVT_BUTTON, self.onRunButton, runB)

        self.abortB = abortB = wx.Button(panel, -1, "Abort")        
        abortB.Enable(False)
        self.Bind(wx.EVT_BUTTON, self.onAbortButton, abortB)

        self.optionsB = optionsB = wx.Button(panel, -1, "Options")        
        self.Bind(wx.EVT_BUTTON, self.onOptionsButton, optionsB)


        topGridSizer.AddMany([ l1, t1, b1,
                               l2, t2, b2,
                               l3, t3, (0,0),
                               (0,0), (0,0,), (0,0,),
                               optionsB, (0,0,), runB,
                               (0,0,), (0,0,), abortB
                               ])

#         topGridSizer.AddMany([ l1, t1, b1,
#                                l2, t2, b2,
#                                (0,0), (0,0,), (0,0,),
#                                optionsB, (0,0,), runB,
#                                (0,0,), (0,0,), abortB
#                                ])

        panel.SetSizer(tabSizer)
        panel.SetAutoLayout(True)
        panel.SetupScrolling()

        # Frame sizer:
        frameSizer = wx.BoxSizer(wx.VERTICAL)    
        frameSizer.SetMinSize((600, 290))
        #frameSizer.SetMinSize((595, 260))
        # Add the note book to the frame sizer:
        frameSizer.Add(panel, 1, wx.EXPAND|wx.ALL, 10)
        # Set the frame sizer:
        self.SetSizer(frameSizer)
        # Fit the frame sizer to the frame:
        frameSizer.Fit(self)

        self.Layout()


    def openProject(self, evt):

        if self.abortB.IsEnabled():
           dlg = wx.MessageDialog(self, 'You need to finish or abort you current analysis before you can open a new project.', 'Analysis running.', wx.OK | wx.ICON_INFORMATION)
           dlg.ShowModal()
           dlg.Destroy()
           return
     
        projectWildcard = "SAP projects (*.sap)|*.sap|"     \
                   "All files (*.*)|*.*"

        dlg = wx.FileDialog(
            self, message="Choose *.sap file in the directory of the project you want to open.",
            defaultDir=os.getcwd(), 
            defaultFile="",
            wildcard=projectWildcard,
            #style=wx.OPEN | wx.MULTIPLE | wx.CHANGE_DIR
            style=wx.OPEN | wx.MULTIPLE
            )

        if dlg.ShowModal() == wx.ID_OK:
            paths = dlg.GetPaths()
            optionsFile = paths[0]
            # Load options into parser:
            pickleFile = open(optionsFile, 'r')
            optionParser.options = pickle.load(pickleFile)
            pickleFile.close()
            self.t2.SetValue(optionParser.options.project)

            # Get names of input files and Update input file field:
            globExpr = os.path.join(optionParser.options.datadir, '*.fasta')
            inputFiles = glob.glob(globExpr)
            self.t1.SetValue(" ".join(inputFiles))

        dlg.Destroy()

    def onQuit(self, evt):
       
        dlg = wx.MessageDialog(self, "Sure you want to quit?", "Quit SAP", wx.YES_NO | wx.ICON_QUESTION)
        
        if dlg.ShowModal() == wx.ID_YES:
            dlg.Destroy()
            self.Destroy() # frame
            # Kill externally by calling SIGKILL or what that corresponds to on windows:
            killExternally()
        else:
           dlg.Destroy()
          
    def OnWindowDestroy(self, evt):
        # Kill externally by calling SIGKILL or what that corresponds to on windows:
        killExternally()
          
 
    def _resultProducer(self, jobID, abortEvent, inputFiles):

        try:

            sys.stdout = OutputEnqueue()

            global optionParser

            # Make directories and write fixed inputfiles:
            init = Initialize(optionParser.options)
            init.createDirs()
    
            inputFiles, seqCount, sequenceNameMap = init.fixAndMoveInput(inputFiles)
            init.checkCacheConsistency(inputFiles)
        
            fastaFileBaseNames = []
    
            try:
               alignmentPlugin = findPlugin(optionParser.options.alignment, 'SAP.alignment')
            except PluginNotFoundError:
               exec("from SAP.Alignment import %s as alignmentPlugin" % optionParser.options.alignment)
            aligner = alignmentPlugin.Aligner(optionParser.options)

            try:
               assignmentPlugin = findPlugin(optionParser.options.assignment, 'SAP.assignment')
            except PluginNotFoundError:
               exec("from SAP.Assignment import %s as assignmentPlugin" % optionParser.options.assignment)
            assignment = assignmentPlugin.Assignment(optionParser.options)


            uniqueDict = {}
            copyLaterDict = {}

            homolcompiler = HomolCompiler(optionParser.options)

            inputQueryNames = {}
    
            # For each fasta file execute pipeline
            for fastaFileName in inputFiles:
    
                fastaFile = open(fastaFileName, 'r')
                fastaIterator = Fasta.Iterator(fastaFile, parser=Fasta.RecordParser())
                fastaFileBaseName = os.path.splitext(os.path.basename(fastaFileName))[0]
                fastaFileBaseNames.append(fastaFileBaseName)
    
                if abortEvent():
                    return jobID

                inputQueryNames[fastaFileBaseName] = {}
                
                for fastaRecord in fastaIterator:

                    
                    # Discard the header except for the first id word:
                    fastaRecord.title = re.search(r'^(\S+)', fastaRecord.title).group(1)

                    inputQueryNames[fastaFileBaseName][fastaRecord.title] = True
    
                    print "%s -> %s: " % (fastaFileBaseName, fastaRecord.title)
    
                    # See if the sequence is been encountered before and if so skip it for now:
                    if uniqueDict.has_key(fastaRecord.sequence):
                        copyLaterDict.setdefault(uniqueDict[fastaRecord.sequence], []).append('%s_%s' % (fastaFileBaseName, fastaRecord.title))
                        print '\tsequence double - skipping...\n'
                        continue
                    else:
                        uniqueDict[fastaRecord.sequence] = '%s_%s' % (fastaFileBaseName, fastaRecord.title)
    
                    # Find homologues: Fasta files and pickled homologyResult objects are written to homologcache
                    homologyResult = homolcompiler.compileHomologueSet(fastaRecord, fastaFileBaseName)

                    if abortEvent():
                        return jobID
    
                    if homologyResult != None:
                        # The homologyResult object serves as a job carrying the relevant information.

                        aligner.align(os.path.join(optionParser.options.homologcache, homologyResult.homologuesFileName))
    
                        if abortEvent():
                            return jobID
                         
                        try:
                           assignment.run(os.path.join(optionParser.options.alignmentcache, homologyResult.alignmentFileName))
                        except assignmentPlugin.AssignmentError, X:
                           print X.msg
    
                        if abortEvent():
                            return jobID
    
                        treeStatistics = TreeStatistics(optionParser.options)
                        treeStatistics.runTreeStatistics([os.path.join(optionParser.options.homologcache, homologyResult.homologuesPickleFileName)], generateSummary=False)

                        if abortEvent():
                            return jobID                        

                fastaFile.close()
    
            if abortEvent():
                return jobID
    
#             # Calculate the pairwise differences between sequences in each file:
#             if optionParser.options.diffs:
#                 pairwisediffs = PairWiseDiffs(optionParser.options)
#                 pairwisediffs.runPairWiseDiffs(inputFiles)
#                 #runPairWiseDiffs(inputFiles)
#     
#             if abortEvent():
#                 return jobID
    
    
            # Make dictionary to map doubles the ones analyzed:
            doubleToAnalyzedDict = {}
            for k, l in copyLaterDict.items():
                doubleToAnalyzedDict.update(dict([[v,k] for v in l]))
    
            if not optionParser.options.nocopycache and len(doubleToAnalyzedDict):
                # Copy cache files for sequences that occoured more than once:
                print "Copying cached results for %d doubles" % len(doubleToAnalyzedDict)
                copyCacheForSequenceDoubles(copyLaterDict, optionParser.options)
                
            # Calculate the pairwise differences between sequences in each file:
            if optionParser.options.diffs:
                pairwisediffs = PairWiseDiffs(optionParser.options)
                pairwisediffs.runPairWiseDiffs(inputFiles)

            if abortEvent():
                return jobID

            # Summary tree stats:
            print 'Computing tree statistics summary...'
            treeStatistics = TreeStatistics(optionParser.options)
            treeStatistics.runTreeStatistics(inputFiles, generateSummary=True, doubleToAnalyzedDict=doubleToAnalyzedDict, inputQueryNames=inputQueryNames)
            print "done"
    
            if abortEvent():
                return jobID
    
            # Make HTML output:
            print '\tGenerating HTML output...'
    
            resultHTML = ResultHTML(optionParser.options)
            resultHTML.webify([optionParser.options.treestatscache + '/summary.pickle'], fastaFileBaseNames, doubleToAnalyzedDict, sequenceNameMap)
            print 'done'
    
            return jobID

        except SystemExit, exitVal:
            sys.exit(exitVal)
        except AnalysisTerminated, exe:
            print "#########################################################################"
            print exe.msg
            print "#########################################################################"
            raise Exception
        except delayedresult.AbortedException:           
            return None
        except Exception, exe: 
            print """
## SAP crached, sorry ###################################################
Help creating a more stable program by sending all the debugging information
between the lines and your SAP version number to kaspermunch@gmail.com along
with *.sap file in the project folder and the sequence input file used.
"""
            print "".join(traceback.format_tb(sys.exc_info()[2]))
            print exe
            print "#################################################################"
            raise Exception

    
    def onAbortButton(self, event): 
        """Abort the result computation."""
        print "\n[Aborting cleanly after completion of current subtask...]"
        self.abortB.Enable(False)
        self.abortEvent.set()
        dlg = wx.MessageDialog(self, 'Analysis is aborting after completion of next sub-task. This is ensures that all retrievals and computations are cached. If you want to discard the analysis altogether quit SAP.\n\nIf you want to force abortion you have to quit SAP.', 'Aborting.', wx.OK | wx.ICON_INFORMATION)
        dlg.ShowModal()
        dlg.Destroy()
        
    def _resultConsumer(self, delayedResult):
        jobID = delayedResult.getJobID()
        assert jobID == self.jobID
        result = None
        try:
            result = delayedResult.get()
        except Exception, exc:
            traceback.print_tb(sys.exc_info()[2])
            print "Result for job %s raised exception: %s" % (jobID, exc)

        # get ready for next job:
        self.runB.Enable(True)
        self.runB.SetDefault()
        self.optionsB.Enable(True)
        self.b1.Enable(True)
        self.b2.Enable(True)
        self.t1.Enable(True)
        self.t2.Enable(True)
        self.abortB.Enable(False)

        if result is not None:
           self.resultPath =  os.path.join(optionParser.options.resultdir, 'index.html')
           self.showResults(None)

                
    def onRunButton(self, evt):

        global optionParser
        inputFiles = re.split(r'\s+', self.t1.GetValue().strip())

        optionParser.options.project = self.t2.GetValue()

        optionParser.options.email =  self.t3.GetValue()

        if not inputFiles or not optionParser.options.project:
            dlg = wx.MessageDialog(self, 'You need to specify an input sequence file and a project folder before you can start the analysis',
                                   'Missing input information.',
                                   wx.OK | wx.ICON_ERROR
                                   #wx.YES_NO | wx.NO_DEFAULT | wx.CANCEL | wx.ICON_INFORMATION
                                   #wx.OK | wx.ICON_INFORMATION
                                   )
            dlg.ShowModal()
            dlg.Destroy()
            return

        optionParser.postProcess(guiParent=self)

        self.logframe.Show(True)

        self.runB.Enable(False)
        self.optionsB.Enable(False)
        self.b1.Enable(False)
        self.b2.Enable(False)
        self.t1.Enable(False)
        self.t2.Enable(False)
        self.abortB.Enable(True)
        self.abortB.SetDefault()
        self.abortEvent.clear()
        self.jobID += 1
        delayedresult.startWorker(self._resultConsumer, self._resultProducer, 
                                  wargs=(self.jobID, self.abortEvent, inputFiles), jobID=self.jobID)

    def onOptionsButton(self, evt):

        dlg = OptionsDialog(self)
        dlg.CenterOnScreen()

#         # this does not return until the dialog is closed.
#         val = dlg.ShowModal()

        if dlg.ShowModal() == wx.ID_OK:        
           # See if we are using any 
           global optionParser
           if os.path.exists(optionParser.options.database):
              assertBlastInstalled(guiParent=self)


        dlg.Destroy()

    def showResults(self, evt):
        global optionParser

        if not self.resultPath:
            projectDir = optionParser.options.project = self.t2.GetValue()
            self.resultPath =  os.path.join(projectDir, optionParser.options.resultdir, 'index.html')
            
        if self.resultPath and os.path.exists(self.resultPath):

            resultLink = hyperlink.HyperLinkCtrl(self, wx.ID_ANY, "", URL="")
        
            strs = "Open results in current default browser? "
            strs = strs + "(Looks best in Firefox or Safari)"
            nResult = wx.MessageBox(strs, "View results", wx.OK |
                                    wx.CANCEL | wx.ICON_QUESTION, self)

            resultURL = 'file://' + self.resultPath
            if nResult == wx.OK:
                resultLink.GotoURL(resultURL, True, True)
        else:
            wx.MessageBox("No results generated yet. You will be notivied when the analysis completes.", "Mesasge")
                        
    def menu203(self, evt):
        self.logframe.Show(True)
        pass

    def menu301(self, evt):

       resultLink = hyperlink.HyperLinkCtrl(self, wx.ID_ANY, "", URL="")
       resultLink.GotoURL(self.webSite, True, False)
        
    def menu302(self, evt):
        # First we create and fill the info object
        info = wx.AboutDialogInfo()
        #info.SetIcon(wx.Icon('/Users/kasper/Desktop/happy48.png', wx.BITMAP_TYPE_PNG))
        info.Name = "SAP"
        info.Version = "1.0"
        info.Copyright = "(C) 2006 Kasper Munch"
        info.Description = wordwrap(
            "SAP is a program for statistical assingment of a unknown"
            "DNA sequence to taxa represented by sequences in GenBank."
            "\n\nIt uses a Bayesian appraoch to estimate a posterior probability of assignment.",
            350, wx.ClientDC(self))
        info.WebSite = (self.webSite, "SAP Homepage")
        info.Developers = [ "Kasper Munch",
                            "Wouter Boomsma",
                            "John Huelsenbeck"]
        licenseText = "SAP is distributed under the Gnu Public License"
        info.License = wordwrap(licenseText, 500, wx.ClientDC(self))
        # Then we call wx.AboutBox giving it that info object
        wx.AboutBox(info)


    def OnCloseMe(self, event):
        self.Close(True)

    def OnCloseWindow(self, event):
        self.Destroy()


    def onFileBrowseButton(self, evt):

        # Create the dialog. In this case the current directory is forced as the starting
        # directory for the dialog, and no default file name is forced. This can easilly
        # be changed in your program. This is an 'open' dialog, and allows multitple
        # file selections as well.
        #
        # Finally, if the directory is changed in the process of getting files, this
        # dialog is set up to change the current working directory to the path chosen.
        dlg = wx.FileDialog(
            self, message="Choose a Fasta file",
            defaultDir=os.getcwd(), 
            defaultFile="",
            wildcard=wildcard,
            style=wx.OPEN | wx.MULTIPLE | wx.CHANGE_DIR
            )

        # Show the dialog and retrieve the user response. If it is the OK response, 
        # process the data.
        if dlg.ShowModal() == wx.ID_OK:
            # This returns a Python list of files that were selected.
            paths = dlg.GetPaths()
            self.inputFiles = paths
            #self.t1.Clear()
            self.t1.WriteText("\n".join(paths))
            #print 'You selected %d files:' % len(paths)

            inputFiles = paths

        # Destroy the dialog. Don't do this until you are done with it!
        # BAD things can happen otherwise!
        dlg.Destroy()

    def onDirBrowseButton(self, evt):

        global optionParser

        # In this case we include a "New directory" button. 
        dlg = wx.DirDialog(self, "Choose a directory:",
                          style=wx.DD_DEFAULT_STYLE
                           #| wx.DD_DIR_MUST_EXIST
                           #| wx.DD_CHANGE_DIR
                           )

        # If the user selects OK, then we process the dialog's data.
        # This is done by getting the path data from the dialog - BEFORE
        # we destroy it. 
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            self.t2.Clear()
            self.t2.WriteText(path)
            optionParser.options.project = path
            
        # Only destroy a dialog after you're done with it.
        dlg.Destroy()

    def onSaveFileButton(self, evt):

        # Create the dialog. In this case the current directory is forced as the starting
        # directory for the dialog, and no default file name is forced. This can easilly
        # be changed in your program. This is an 'save' dialog.
        #
        # Unlike the 'open dialog' example found elsewhere, this example does NOT
        # force the current working directory to change if the user chooses a different
        # directory than the one initially set.
        dlg = wx.FileDialog(
            self, message="Save file as ...", defaultDir=os.getcwd(), 
            defaultFile="", wildcard=wildcard, style=wx.SAVE
            )

        # This sets the default filter that the user will initially see. Otherwise,
        # the first filter in the list will be used by default.
        dlg.SetFilterIndex(2)

        # Show the dialog and retrieve the user response. If it is the OK response, 
        # process the data.
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()

            # Normally, at this point you would save your data using the file and path
            # data that the user provided to you, but since we didn't actually start
            # with any data to work with, that would be difficult.
            # 
            # The code to do so would be similar to this, assuming 'data' contains
            # the data you want to save:
            #
            # fp = file(path, 'w') # Create file anew
            # fp.write(data)
            # fp.close()
            #
            # You might want to add some error checking :-)
            #

        # Destroy the dialog. Don't do this until you are done with it!
        # BAD things can happen otherwise!
        dlg.Destroy()

class MyApp(wx.App):

    def OnInit(self):

        wx.InitAllImageHandlers()
        frame_1 = MyFrame(None, -1, "")
        frame_1.CenterOnScreen()
        self.SetTopWindow(frame_1)

        assertNetblastInstalled(guiParent=frame_1)
        assertClustalw2Installed(guiParent=frame_1)

        frame_1.Show()
        return 1
    
    def OpenFileMessage(self, filename):
        dlg = wx.MessageDialog(None,
                               "This app was just asked to open:\n%s\n"%filename,
                               "File Dropped",
                               wx.OK|wx.ICON_INFORMATION)
        dlg.ShowModal()
        dlg.Destroy()

    def MacOpenFile(self, filename):
        print filename
        print "%s dropped on app"%(filename) #code to load filename goes here.
        self.OpenFileMessage(filename)

def start_gui():
    app = MyApp(0)
    app.MainLoop()

if __name__ == "__main__":

   start_gui()
